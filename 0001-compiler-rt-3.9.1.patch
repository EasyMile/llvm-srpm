From d2dfd53655ca69b30a5f9857776c62a62b5f6208 Mon Sep 17 00:00:00 2001
From: Dan Aloni <dan.aloni@parallelmachines.com>
Date: Sun, 29 Jan 2017 18:24:27 +0200
Subject: [PATCH] compiler-rt-3.9.1

---
 lib/builtins/gcc_personality_v0.c                  | 11 +++++
 lib/builtins/unwind-ehabi-helpers.h                | 55 ++++++++++++++++++++++
 .../TestCases/Linux/sem_init_glibc.cc              | 19 +++++++-
 3 files changed, 83 insertions(+), 2 deletions(-)
 create mode 100644 lib/builtins/unwind-ehabi-helpers.h

diff --git a/lib/builtins/gcc_personality_v0.c b/lib/builtins/gcc_personality_v0.c
index 29e5be30712f..0bc765624564 100644
--- a/lib/builtins/gcc_personality_v0.c
+++ b/lib/builtins/gcc_personality_v0.c
@@ -12,6 +12,17 @@
 #include "int_lib.h"
 
 #include <unwind.h>
+#if defined(__arm__) && !defined(__ARM_DWARF_EH__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+/*
+ * When building with older compilers (e.g. clang <3.9), it is possible that we
+ * have a version of unwind.h which does not provide the EHABI declarations
+ * which are quired for the C personality to conform to the specification.  In
+ * order to provide forward compatibility for such compilers, we re-declare the
+ * necessary interfaces in the helper to permit a standalone compilation of the
+ * builtins (which contains the C unwinding personality for historical reasons).
+ */
+#include "unwind-ehabi-helpers.h"
+#endif
 
 /*
  * Pointer encodings documented at:
diff --git a/lib/builtins/unwind-ehabi-helpers.h b/lib/builtins/unwind-ehabi-helpers.h
new file mode 100644
index 000000000000..ccb0765975a9
--- /dev/null
+++ b/lib/builtins/unwind-ehabi-helpers.h
@@ -0,0 +1,55 @@
+/* ===-- arm-ehabi-helpers.h - Supplementary ARM EHABI declarations --------===
+ *
+ *                     The LLVM Compiler Infrastructure
+ *
+ * This file is dual licensed under the MIT and the University of Illinois Open
+ * Source Licenses. See LICENSE.TXT for details.
+ *
+ * ===--------------------------------------------------------------------=== */
+
+#ifndef UNWIND_EHABI_HELPERS_H
+#define UNWIND_EHABI_HELPERS_H
+
+#include <stdint.h>
+/* NOTE: see reasoning for this inclusion below */
+#include <unwind.h>
+
+#if !defined(__ARM_EABI_UNWINDER__)
+
+/*
+ * NOTE: _URC_OK, _URC_FAILURE must be present as preprocessor tokens.  This
+ * allows for a substitution of a constant which can be cast into the
+ * appropriate enumerated type.  This header is expected to always be included
+ * AFTER unwind.h (which is why it is forcefully included above).  This ensures
+ * that we do not overwrite the token for the enumeration.  Subsequent uses of
+ * the token would be clean to rewrite with constant values.
+ *
+ * The typedef redeclaration should be safe.  Due to the protection granted to
+ * us by the `__ARM_EABI_UNWINDER__` above, we are guaranteed that we are in a
+ * header not vended by gcc.  The HP unwinder (being an itanium unwinder) does
+ * not support EHABI, and the GNU unwinder, derived from the HP unwinder, also
+ * does not support EHABI as of the introduction of this header.  As such, we
+ * are fairly certain that we are in the LLVM case.  Here, _Unwind_State is a
+ * typedef, and so we can get away with a redeclaration.
+ *
+ * Guarded redefinitions of the needed unwind state prevent the redefinition of
+ * those states.
+ */
+
+#define _URC_OK       0
+#define _URC_FAILURE  9
+
+typedef uint32_t _Unwind_State;
+
+#if !defined(_US_UNWIND_FRAME_STARTING)
+#define _US_UNWIND_FRAME_STARTING ((_Unwind_State)1)
+#endif
+
+#if !defined(_US_ACTION_MASK)
+#define _US_ACTION_MASK ((_Unwind_State)3)
+#endif
+
+#endif
+
+#endif
+
diff --git a/test/sanitizer_common/TestCases/Linux/sem_init_glibc.cc b/test/sanitizer_common/TestCases/Linux/sem_init_glibc.cc
index 193b33d7976d..ff1ddc432d4e 100644
--- a/test/sanitizer_common/TestCases/Linux/sem_init_glibc.cc
+++ b/test/sanitizer_common/TestCases/Linux/sem_init_glibc.cc
@@ -17,6 +17,21 @@ typedef uint64_t semval_t;
 typedef unsigned semval_t;
 #endif
 
+// glibc 2.21 has introduced some changes in the way the semaphore value is
+// handled for 32-bit platforms, but since these changes are not ABI-breaking
+// they are not versioned. On newer platforms such as ARM, there is only one
+// version of the symbol, so it's enough to check the glibc version. However,
+// for old platforms such as i386, glibc contains two or even three versions of
+// the sem_init symbol, and the sanitizers always pick the oldest one.
+// Therefore, it is not enough to rely on the __GLIBC_PREREQ macro - we should
+// instead check the platform as well to make sure we only expect the new
+// behavior on platforms where the older symbols do not exist.
+#if defined(__arm__) && __GLIBC_PREREQ(2, 21)
+#define GET_SEM_VALUE(V) ((V) >> 1)
+#else
+#define GET_SEM_VALUE(V) (V)
+#endif
+
 void my_sem_init(bool priv, int value, semval_t *a, unsigned char *b) {
   sem_t sem;
   memset(&sem, 0xAB, sizeof(sem));
@@ -34,10 +49,10 @@ int main() {
   unsigned char b;
 
   my_sem_init(false, 42, &a, &b);
-  assert(a == 42);
+  assert(GET_SEM_VALUE(a) == 42);
   assert(b != 0xAB);
 
   my_sem_init(true, 43, &a, &b);
-  assert(a == 43);
+  assert(GET_SEM_VALUE(a) == 43);
   assert(b != 0xAB);
 }
-- 
2.7.4

